


/* State Management Issues:
_state.player (template object) is being confused with _state.game.players 
(actual player data)
Resources are stored in both player.resources and _state.playerResources
Resource Display Issues:
The display code in 
updateResourceDisplays
 assumes resources are in player.resources
Some code might still be updating _state.playerResources instead
End Game Issues:
Final scores aren't being calculated correctly because resources aren't 
being tracked consistently
Proposed Fixes:
Unify Resource Storage:
Choose one location to store resources (preferably directly in player objects)
Update all resource-related functions to use this single source
Update Resource Display:
Modify 
updateResourceDisplays
 to use the correct resource location
Ensure all resource updates trigger a display update
Fix End Game Calculation:
Make sure final resource totals are calculated from the correct source
Update the end game screen to display the correct values
Would you like me to start implementing these fixes? I can begin with the most critical issue first.

Feedback submitted
Close
2 days ago
17 hours ago
15 minutes ago
Press Enter again to interrupt and send a new message


Here's a summary of where player resources are being used:

player.resources is used in:
ui.js:
Updates UI display of resources
Shows knowledge, money, and influence counts
resourceManagement.js:
Main resource handling logic
Updates and tracks resource values
Handles resource changes and calculations
players.js:
Player creation and management
Debug logging of resources
Resource initialization and updates
state.playerResources is used in:
state.js:
Storage of player resources by ID
Part of the main state management
resourceManagement.js:
getPlayerResources()
 function
Fallback for resource lookups
players.js:
getPlayerResources()
 function
Resource initialization
Key Issues:
Dual Storage:
Resources are stored in both player.resources and state.playerResources
This can lead to synchronization issues
Inconsistent Access:
Some code uses player.resources directly
Other code uses 
getPlayerResources()
State Management:
_state.player was removed, but some code might still reference it
Need to ensure all code uses _state.game.players
Recommendation:
Choose One Storage Method:
Prefer player.resources for direct access
Remove state.playerResources entirely
Update All References:
Replace 
getPlayerResources()
 with direct player.resources access
Ensure all resource updates go through a single function
Test Thoroughly:
Resource updates
UI display
End game calculations

In state.js:
Update the 
updatePlayerResources
 function to use the new structure:
javascript
export function updatePlayerResources(playerId, resources) {
    _state.player.resources[playerId] = JSON.parse(JSON.stringify(resources));
    notifySubscribers();
}
In ui.js:
updateResourceDisplayContainer
 function needs to use the new path:
javascript
panelUpdated.querySelector('.KNOWLEDGE_COUNT').textContent = `Knowledge ${player.resources.money}`;
panelUpdated.querySelector('.MONEY_COUNT').textContent = `Money ${player.resources.knowledge}`;
panelUpdated.querySelector('.INFLUENCE_COUNT').textContent = `Influence ${player.resources.influence}`;
In resourceManagement.js:
handleStealEffect
 needs to be updated to use the new path:
javascript
const targetResources = state.player.resources[targetPlayer.id] || {};
In players.js:
getPlayerScore
 function (commented out but should be updated if used):
javascript
// score += Object.values(state.player.resources[player.id] || {}).reduce((sum, val) => sum + val, 0);
In cards.js:
Any direct resource access should be updated to use the new path through state.player.resources[playerId]
The main changes involve:

Replacing direct player.resources access with state.player.resources[playerId]
Updating any functions that modify resources to use the new centralized state
Ensuring all resource reads go through the state object
Would you like me to help implement any of these changes? I can make the updates systematically to ensure everything works correctly with the new state structure.
*/

/**
 * Updates the player information panel with the current player's stats.
 * @param {Object} [newValues] - Optional new resource values to display
 */
export function updatePlayerInfo(player, changes = {}, gameState = state) {
    console.log('==============updatePlayerInfo=============');
    
    try {
        // Get current player if none provided
        if (!player) {
            player = getCurrentPlayer();
            if (!player) {
                console.warn('updatePlayerInfo: No current player found');
                return;
            }
        }
        
        console.log('[UI] Found player:', {
            id: player.id,
            name: player.name,
            role: player.role,
            resources: player.resources,
            isHuman: player.isHuman
        });
        
        // Get UI elements
        const { currentPlayer: playerElement, KNOWLEDGE_COUNT, MONEY_COUNT, INFLUENCE_COUNT } = state.ui.elements.gameBoard || {};
        
        console.log('[UI] UI Elements:', {
            currentPlayer: !!playerElement,
            KNOWLEDGE_COUNT: !!KNOWLEDGE_COUNT,
            MONEY_COUNT: !!MONEY_COUNT,
            INFLUENCE_COUNT: !!INFLUENCE_COUNT
        });
        
        if (!playerElement || !KNOWLEDGE_COUNT || !MONEY_COUNT || !INFLUENCE_COUNT) {
            console.error('updatePlayerInfo: Missing required UI elements');
            // Try to re-initialize UI elements if they're missing
            if (typeof initializeElementReferences === 'function') {
                console.log('-----------initializing UI elements-----------');
                initializeElementReferences();
            }
            return;
        }
    
        // Ensure resources exist, default to 0 if not
        const resources = player.resources || {};
        const knowledge = resources.knowledge ?? 0;
        const money = resources.money ?? 0;
        const influence = resources.influence ?? 0;
        
        console.log('[UI] Updating UI with resources:', { knowledge, money, influence });
        
        // Update the main player info elements
        playerElement.textContent = `${player.name} (${player.role || 'No Role'})`;
        KNOWLEDGE_COUNT.textContent = changes.knowledge ?? knowledge;
        MONEY_COUNT.textContent = changes.money ?? money;
        INFLUENCE_COUNT.textContent = changes.influence ?? influence;
        
        // Get all players for display logic
        const players = getPlayers();
        if (!players || !players.length) {
            console.warn('No players found in game state');
            return;
        }

        // Get the display containers from the HTML
        const resourceDisplayContainer = document.getElementById('resource-Display-Container');
        const playerScoreDisplay = document.querySelector('.player-Score-Display');

        // Safety check to ensure the containers exist in your HTML
        if (!resourceDisplayContainer || !playerScoreDisplay) {
            console.warn("Resource display containers not found. Please check the IDs in your index.html.");
            return;
        }

        const humanPlayers = players.filter(p => p.isHuman);
        const aiPlayers = players.filter(p => !p.isHuman);

        let playerForBottomDisplay = null;

        // --- Logic for the Bottom Display Container ---
        // If there's only one human player, always show them.
        if (humanPlayers.length === 1) {
            playerForBottomDisplay = humanPlayers[0];
        } 
        // If there are multiple human players, show the one whose turn it is.
        else if (humanPlayers.length > 1) {
            if (player?.isHuman) {
                playerForBottomDisplay = player;
            }
        }

        // Populate the bottom display if a player has been selected
        if (playerForBottomDisplay) {
            // Update existing DOM elements directly
            const currentPlayerSpan = document.getElementById('currentPlayer');
            const knowledgeCount = document.getElementById('KNOWLEDGE_COUNT');
            const moneyCount = document.getElementById('MONEY_COUNT');
            const influenceCount = document.getElementById('INFLUENCE_COUNT');
    
            if (currentPlayerSpan) {
                currentPlayerSpan.textContent = playerForBottomDisplay.role || 'Player';
            }
            if (knowledgeCount) {
                knowledgeCount.textContent = changes.knowledge ?? (playerForBottomDisplay.resources?.knowledge || 0);
            }
            if (moneyCount) {
                moneyCount.textContent = changes.money ?? (playerForBottomDisplay.resources?.money || 0);
            }
            if (influenceCount) {
                influenceCount.textContent = changes.influence ?? (playerForBottomDisplay.resources?.influence || 0);
            }
        }

        // --- Logic for the Top Score Display ---
        const playersForTopDisplay = [];

        // Add all AI players who are active in the game
        aiPlayers.forEach(aiPlayer => {
            if (players.includes(aiPlayer)) {
                playersForTopDisplay.push(aiPlayer);
            }
        });

        // Add any human players who are NOT being shown in the bottom display
        humanPlayers.forEach(humanPlayer => {
            if (humanPlayer !== playerForBottomDisplay && players.includes(humanPlayer)) {
                playersForTopDisplay.push(humanPlayer);
            }
        });

        // Get existing player score elements
        const playerScoreElements = playerScoreDisplay.querySelectorAll('h5');

        // Update existing player score elements
        playerScoreElements.forEach((element, index) => {
            const roleNameSpan = element.querySelector('.role-Name');
            const resourceParagraph = element.querySelector('p');
    
            if (index < playersForTopDisplay.length) {
                const displayPlayer = playersForTopDisplay[index];
                const roleName = displayPlayer.role || `Player ${displayPlayer.id?.slice(0, 4) || '?'}`;
                const displayResources = displayPlayer.resources || {};
                
                if (roleNameSpan) {
                    roleNameSpan.textContent = roleName;
                }
                if (resourceParagraph) {
                    resourceParagraph.textContent = `${displayResources.money || 0} ðŸ’°, ${displayResources.knowledge || 0} ðŸ§ , ${displayResources.influence || 0} âš¡`;
                }
                
                // Make sure the element is visible
                element.style.display = '';
            } else {
                // Hide unused elements
                element.style.display = 'none';
            }
        });
        
        // Force a reflow to ensure the UI updates
        void playerElement.offsetHeight;
        
        console.log('=============updatePlayerInfo END=============');
        
    } catch (error) {
        console.error('Error in updatePlayerInfo:', error);
        // Try a full UI refresh on error
        try {
            if (typeof initializeUI === 'function') initializeUI();
            if (typeof updateGameControls === 'function') updateGameControls();
        } catch (e) {
            console.error('Failed to refresh UI:', e);
        }
    }
};

/**
 * Update a player's resources in global state by applying changes (deltas)
 * @param {string|Object} player - The player ID, player object, or changes object if using current player
 * @param {Object} [changes] - The resource changes to apply (can be positive or negative)
 * @returns {boolean} - True if update succeeded, false otherwise
 */
export function updatePlayerResources(player, changes) {
    console.log('=============updatePlayerResources=============');
    
    let targetPlayer;
    let resourceChanges;
    
    // Handle single parameter call (just changes object for current player)
    if (arguments.length === 1 && typeof player === 'object' && !Array.isArray(player)) {
        const currentPlayer = getCurrentPlayer();
        if (!currentPlayer) {
            console.error('No current player found');
            return false;
        }
        targetPlayer = currentPlayer;
        resourceChanges = player;
    } else if (!changes) {
        // If changes is not provided, treat the first param as changes for current player
        const currentPlayer = getCurrentPlayer();
        if (!currentPlayer) {
            console.error('No current player found');
            return false;
        }
        targetPlayer = currentPlayer;
        resourceChanges = player;
    } else {
        // Two parameters provided
        // If player is a string, treat it as playerId
        if (typeof player === 'string') {
            if (!_state.game.players[player]) {
                console.error(`Player with ID ${player} not found`);
                return false;
            }
            targetPlayer = _state.game.players[player];
        } else {
            // Player object provided
            targetPlayer = player;
        }
        resourceChanges = changes;
    }
    
    if (!targetPlayer || !resourceChanges) {
        console.error('Invalid parameters for updatePlayerResources:', { 
            player: targetPlayer?.id || 'undefined', 
            changes: resourceChanges 
        });
        return false;
    }
    
    // Validate player has resources object
    if (!targetPlayer.resources) {
        console.error('Player missing resources object:', targetPlayer);
        return false;
    }
    
    // Define valid resources
    const VALID_RESOURCES = ['money', 'knowledge', 'influence'];
    
    // Validate and normalize changes
    const normalizedChanges = {};
    let isValid = true;
    for (const resource in resourceChanges) {
        if (!VALID_RESOURCES.includes(resource)) {
            console.warn(`Invalid resource type '${resource}' ignored`);
            continue;
        }
        
        const change = Number(resourceChanges[resource]);
        if (isNaN(change)) {
            console.error(`Invalid change value for ${resource}:`, resourceChanges[resource]);
            isValid = false;
            break;
        }
        
        normalizedChanges[resource] = change;
    }
    
    if (!isValid) return false;
    
    // Calculate new values first to ensure all changes are valid
    const newValues = { ...targetPlayer.resources };
    for (const [resource, change] of Object.entries(normalizedChanges)) {
        const currentValue = newValues[resource] || 0;
        const newValue = currentValue + change;
        
        // Prevent negative resources
        if (newValue < 0) {
            console.error(`Cannot update ${resource}: would result in negative value (${newValue})`);
            return false;
        }
        
        newValues[resource] = newValue;
    }
    
    // Apply validated changes to the global state
    _state.game.players[targetPlayer.id].resources = { ...newValues };
    
    // Notify subscribers of state changes
    if (typeof notifySubscribers === 'function') {
        notifySubscribers();
    }
    
    console.log(`[Resources] Updated resources for ${targetPlayer.name || targetPlayer.id}:`, newValues);
    
    return true;
}

/**
 * Initialize player resources in the player object
 * @param {string} playerId - The ID of the player
 * @param {Object} initialResources - Initial resource values
 */
export function initPlayerResources(playerId, initialResources) {
    if (!playerId || !initialResources) {
        console.warn('initPlayerResources: Missing playerId or initialResources');
        return;
    }
    
    const player = getPlayerById(playerId);
    if (!player) {
        console.warn(`initPlayerResources: Player ${playerId} not found`);
        return;
    }
    
    // Initialize resources directly in the player object
    player.resources = {
        knowledge: Number(initialResources.knowledge) || 0,
        money: Number(initialResources.money) || 0,
        influence: Number(initialResources.influence) || 0
    };
    
    console.log(`[Resources] Initialized resources for player ${playerId}:`, player.resources);
}

/**
* Get a player's resources
* @param {string} playerId - The ID of the player
* @returns {Object} Player's resources or null if not found
*/
export function getPlayerResources(playerId) {
    if (!playerId) {
        console.warn('getPlayerResources: No player ID provided');
        return null;
    }
    
    const player = getPlayerById(playerId);
    if (!player) {
        console.warn(`getPlayerResources: Player ${playerId} not found`);
        return { knowledge: 0, money: 0, influence: 0 };
    }
    
    // Ensure player has resources object
    if (!player.resources) {
        player.resources = { knowledge: 0, money: 0, influence: 0 };
    }
    
    return { ...player.resources };
}

/**
 * Update a player's resources in global state by applying changes (deltas)
 * @param {string|Object} player - The player ID, player object, or changes object if using current player
 * @param {Object} [changes] - The resource changes to apply (can be positive or negative)
 * @returns {boolean} - True if update succeeded, false otherwise
 */
export function updatePlayerResources(player, changes) {
    console.log('=============updatePlayerResources=============');
    
    let targetPlayer;
    let resourceChanges;
    
    // Handle single parameter call (just changes object for current player)
    if (arguments.length === 1 && typeof player === 'object' && !Array.isArray(player)) {
        const currentPlayer = getCurrentPlayer();
        if (!currentPlayer) {
            console.error('No current player found');
            return false;
        }
        targetPlayer = currentPlayer;
        resourceChanges = player;
    } else if (!changes) {
        // If changes is not provided, treat the first param as changes for current player
        const currentPlayer = getCurrentPlayer();
        if (!currentPlayer) {
            console.error('No current player found');
            return false;
        }
        targetPlayer = currentPlayer;
        resourceChanges = player;
    } else {
        // Two parameters provided
        // If player is a string, treat it as playerId
        if (typeof player === 'string') {
            if (!_state.game.players[player]) {
                console.error(`Player with ID ${player} not found`);
                return false;
            }
            targetPlayer = _state.game.players[player];
        } else {
            // Player object provided
            targetPlayer = player;
        }
        resourceChanges = changes;
    }
    
    if (!targetPlayer || !resourceChanges) {
        console.error('Invalid parameters for updatePlayerResources:', { 
            player: targetPlayer?.id || 'undefined', 
            changes: resourceChanges 
        });
        return false;
    }
    
    // Validate player has resources object
    if (!targetPlayer.resources) {
        console.error('Player missing resources object:', targetPlayer);
        return false;
    }
    
    // Define valid resources
    const VALID_RESOURCES = ['money', 'knowledge', 'influence'];
    
    // Validate and normalize changes
    const normalizedChanges = {};
    let isValid = true;
    for (const resource in resourceChanges) {
        if (!VALID_RESOURCES.includes(resource)) {
            console.warn(`Invalid resource type '${resource}' ignored`);
            continue;
        }
        
        const change = Number(resourceChanges[resource]);
        if (isNaN(change)) {
            console.error(`Invalid change value for ${resource}:`, resourceChanges[resource]);
            isValid = false;
            break;
        }
        
        normalizedChanges[resource] = change;
    }
    
    if (!isValid) return false;
    
    // Calculate new values first to ensure all changes are valid
    const newValues = { ...targetPlayer.resources };
    for (const [resource, change] of Object.entries(normalizedChanges)) {
        const currentValue = newValues[resource] || 0;
        const newValue = currentValue + change;
        
        // Prevent negative resources
        if (newValue < 0) {
            console.error(`Cannot update ${resource}: would result in negative value (${newValue})`);
            return false;
        }
        
        newValues[resource] = newValue;
    }
    
    // Apply validated changes to the global state
    _state.game.players[targetPlayer.id].resources = { ...newValues };
    
    // Notify subscribers of state changes
    if (typeof notifySubscribers === 'function') {
        notifySubscribers();
    }
    
    console.log(`[Resources] Updated resources for ${targetPlayer.name || targetPlayer.id}:`, newValues);
    
    return true;
}

// ===== State Setters =====

const subscribers = new Set();

/**
 * Subscribe to state changes
 * @param {Function} callback - Function to call when state changes
 * @returns {Function} Unsubscribe function
 */
export function subscribe(callback) {
   // console.log('=============subscribe=============');
    subscribers.add(callback);
    return () => subscribers.delete(callback);
}

export function notifySubscribers() {
   // console.log('=============notifySubscribers=============');
    const state = {
        game: getGameState(),
        ui: getUIState()
    };
    subscribers.forEach(callback => callback(state));
}

export const _state = {
    
    // UI State
    ui: {
        currentScreen: 'start',
        selectedDeck: null,
        highlightedSpace: null,
        isAnimating: false,
        showEndTurnButton: false,
        currentMessage: {
            text: '',
            type: 'info',
            visible: false
        },
        dice: {
            isRolling: false,
            value: 1
        },
        animation: {
            inProgress: false,
            current: null,
            queue: [],
            lastFrameTime: 0,
            frameId: null,
            screenTransition: {
                from: null,
                to: null,
                progress: 0,
                direction: 'right'
            }
        },
        gameboard: {}
    },
    
    // Game State
    game: {
        started: false,
        ended: false,
        currentPhase: 'SETUP',
        currentCard: null,      // Currently active card
        currentDeck: null,      // Current deck type (ageOfExpansion, endOfTurn, etc.)
        players: [],
        aiPlayerCount: 0,
        totalPlayerCount: 0,
        humanPlayerCount: 0,
        debugMode: false,
        currentPlayerIndex: -1,
        turnOrder: [],
        currentPath: null,
        currentCoords: null,
        previousCoords: null,
        remainingSteps: 0,
        pendingActionData: null,
        rollResult: 0,
        pathChoiceLock: false,
        lastRoll: 0,
        turnNumber: 0,
        hasRolled: false,
        drawnCard: false,
        deckType: null,
        phase: 'setup',
        gameStarted: false,
        gameOver: false,
        winners: null,
        playerFinishPosition: 0,
        round: 1,
        maxRounds: 50,
        playerRoles: {},
        playerFinalScore: 0,
        playerFinalResourceTotal: 0,
        playerFinalRanking: 0,
        playerPositions: {},
        abilityUsed: false,
        board: {},
        settings: {
            maxPlayers: 6,
            minPlayers: 4,
            enableSpecialAbilities: true
        },
        resources: {
            knowledge: 0,
            money: 0,
            influence: 0,
        },
        spaceType: { ...SPACE_TYPE }, // Add spaceType to global state.
    },
    
};

// Create proxy for reactivity
export const state = new Proxy(_state.game, {
    set(target, property, value) {
        const oldValue = target[property];
        target[property] = value;
        
        // Only notify subscribers when explicitly requested via a flag
        if (subscribers.size > 0 && oldValue !== value && target._notifyOnChange) {
            notifySubscribers();
        }
        return true;
    }
});