// ===== Fixed Game Ending Functions =====
// Import necessary functions (add these to your imports)
// import { updateGameState, getCurrentPlayer, getPlayers, allPlayersFinished, advanceToNextPlayer } from './state.js';
// import { showScreen } from './ui.js';

/**
 * Marks a player as finished, updates their final scores, and handles game flow
 */
export function markPlayerFinished(playerOrId) {
    if (!playerOrId) {
        console.error('markPlayerFinished: No player provided');
        return;
    }
    
    console.log('=== markPlayerFinished called ===');
    console.log('Input:', playerOrId);
    
    // Get the players array from state
    const players = getPlayers();
    
    if (players.length === 0) {
        console.error('No players in game state');
        return;
    }
    
    // Find the actual player in the state
    let player;
    let playerIndex = -1;
    
    if (typeof playerOrId === 'string' || typeof playerOrId === 'number') {
        // Find player by ID
        playerIndex = players.findIndex(p => p.id === playerOrId);
        if (playerIndex === -1) {
            console.error(`Player with ID ${playerOrId} not found`);
            return;
        }
        player = players[playerIndex];
    } else if (typeof playerOrId === 'object' && playerOrId.id) {
        // Find player by object reference
        playerIndex = players.findIndex(p => p.id === playerOrId.id);
        if (playerIndex === -1) {
            console.error(`Player object not found in state`);
            return;
        }
        player = players[playerIndex];
    } else {
        console.error('Invalid player identifier provided');
        return;
    }
    
    console.log(`Found player: ${player.name} at index ${playerIndex}`);
    console.log(`Player finished status BEFORE: ${player.finished}`);
    
    // Mark player as finished DIRECTLY in the state array
    _state.game.players[playerIndex].finished = true;
    
    console.log(`Player finished status AFTER: ${_state.game.players[playerIndex].finished}`);
    
    // Calculate player's final resource total
    const resources = player.resources || { money: 0, knowledge: 0, influence: 0 };
    const finalResourceTotal = (resources.money || 0) + (resources.knowledge || 0) + (resources.influence || 0);
    
    // Update player's final resource total
    _state.game.players[playerIndex].playerFinalResourceTotal = finalResourceTotal;
    
    // Calculate and assign ranking based on finish position
    const finishedPlayers = _state.game.players.filter(p => p.finished);
    const finishPosition = finishedPlayers.length;
    _state.game.players[playerIndex].playerFinalRanking = finishPosition;
    
    console.log(`Player ${player.name} marked as finished in position ${finishPosition} with ${finalResourceTotal} resources`);
    
    // Trigger state update notification
    updateGameState({
        playerFinishPosition: Math.max(_state.game.playerFinishPosition, finishPosition)
    });
    
    // Verify the change took effect
    const verifyPlayer = _state.game.players[playerIndex];
    console.log(`VERIFICATION - Player ${verifyPlayer.name} finished: ${verifyPlayer.finished}`);
    
    if (allPlayersFinished()) {
        console.log('All players finished - ending game');
        endGame();
    } else {
        console.log('Not all players finished - advancing to next player');
        advanceToNextPlayer();
    }
}

/**
 * Calculates final scores and determines the game winner
 */
export function endGame() {
    console.log('=== ENDING GAME ===');
    
    const players = getPlayers();
    
    if (players.length === 0) {
        console.error('Cannot end game: No players found');
        return;
    }
    
    // Calculate final scores for all players
    players.forEach((player, index) => {
        const resourceTotal = player.playerFinalResourceTotal || 0;
        let rankingBonus = 0;
        
        // Assign ranking bonus based on finish position
        switch(player.playerFinalRanking) {
            case 1: rankingBonus = 25; break;  // 1st place
            case 2: rankingBonus = 20; break;  // 2nd place
            case 3:
            case 4: rankingBonus = 15; break;  // 3rd and 4th place
            case 5:
            case 6: rankingBonus = 10; break;  // 5th and 6th place
            default: rankingBonus = 0; break; // Beyond 6th place
        }
        
        _state.game.players[index].playerFinalScore = resourceTotal + rankingBonus;
        
        console.log(`Player ${player.name}: Resources=${resourceTotal}, Ranking=${player.playerFinalRanking}, Bonus=${rankingBonus}, Final Score=${player.playerFinalScore}`);
    });
    
    // Find all players with the highest final score (handles ties)
    const maxScore = Math.max(...players.map(p => p.playerFinalScore || 0));
    const winners = players.filter(p => p.playerFinalScore === maxScore);
    
    if (winners.length === 1) {
        console.log(`Game Winner: ${winners[0].name} with score ${winners[0].playerFinalScore}`);
    } else {
        console.log(`Game Tie! Winners: ${winners.map(w => w.name).join(', ')} with score ${maxScore}`);
    }
    
    // Update game state
    updateGameState({
        ended: true,
        gameOver: true,
        winner: winners.length === 1 ? winners[0] : winners
    });
    
    // Show the end game screen with victory animation
    showEndGameWithVictory(winners);
}

/**
 * Transitions to end game screen and displays victory celebration
 */
export function showEndGameWithVictory(winners) {
    console.log('=== SHOWING END GAME SCREEN ===');
    
    if (!winners || (Array.isArray(winners) && winners.length === 0)) {
        console.error('No winners provided for victory screen');
        return;
    }
    
    // Handle both single winner and array of winners
    const winnersArray = Array.isArray(winners) ? winners : [winners];
    const primaryWinner = winnersArray[0];
    
    // Transition to end game screen
    showScreen('endGameScreen');
    
    // Make the new game button visible
    const newGameButton = document.getElementById('newGameButton');
    if (newGameButton) {
        newGameButton.style.display = 'block';
        newGameButton.style.visibility = 'visible';
    }
    
    // Start victory celebration animation
    startVictoryCelebration(winnersArray);
}

/**
 * Creates a victory celebration animation for the winner(s)
 */
function startVictoryCelebration(winners) {
    const winnersArray = Array.isArray(winners) ? winners : [winners];
    const primaryWinner = winnersArray[0];
    
    console.log(`Starting victory celebration for ${winnersArray.map(w => w.name).join(', ')}`);
    
    // Create or find celebration container
    let celebrationContainer = document.getElementById('celebrationContainer');
    if (!celebrationContainer) {
        celebrationContainer = document.createElement('div');
        celebrationContainer.id = 'celebrationContainer';
        celebrationContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            overflow: hidden;
        `;
        document.body.appendChild(celebrationContainer);
    }
    
    // Clear any existing celebration
    celebrationContainer.innerHTML = '';
    
    // Handle winner text for single winner or tie
    const winnerText = document.createElement('div');
    if (winnersArray.length === 1) {
        winnerText.textContent = `ðŸŽ‰ ${primaryWinner.name} Wins! ðŸŽ‰`;
    } else {
        winnerText.textContent = `ðŸŽ‰ TIE! ${winnersArray.map(w => w.name).join(' & ')} Win! ðŸŽ‰`;
    }
    
    winnerText.style.cssText = `
        position: absolute;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 3em;
        font-weight: bold;
        color: #ffd700;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        animation: pulse 1.5s infinite, rainbow 3s infinite;
        text-align: center;
        white-space: nowrap;
        max-width: 90%;
        overflow: hidden;
        text-overflow: ellipsis;
    `;
    celebrationContainer.appendChild(winnerText);
    
    // Add score display
    const scoreText = document.createElement('div');
    scoreText.textContent = `Final Score: ${primaryWinner.playerFinalScore}`;
    scoreText.style.cssText = `
        position: absolute;
        top: 35%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.5em;
        color: #fff;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        text-align: center;
    `;
    celebrationContainer.appendChild(scoreText);
    
    // Create floating confetti animation
    createConfetti(celebrationContainer);
    
    // Add CSS animations if not already present
    addCelebrationStyles();
    
    // Clean up celebration after 5 seconds
    setTimeout(() => {
        if (celebrationContainer && celebrationContainer.parentNode) {
            celebrationContainer.style.opacity = '0';
            celebrationContainer.style.transition = 'opacity 1s ease-out';
            setTimeout(() => {
                if (celebrationContainer && celebrationContainer.parentNode) {
                    celebrationContainer.remove();
                }
            }, 1000);
        }
    }, 5000);
}

/**
 * Adds CSS styles for celebration animations
 */
function addCelebrationStyles() {
    const styleId = 'celebrationStyles';
    
    // Prevent duplicate style injection
    if (document.getElementById(styleId)) return;
    
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }
        
        @keyframes rainbow {
            0% { color: #ff6b6b; }
            16.66% { color: #4ecdc4; }
            33.33% { color: #45b7d1; }
            50% { color: #96ceb4; }
            66.66% { color: #feca57; }
            83.33% { color: #ff9ff3; }
            100% { color: #ff6b6b; }
        }
        
        @keyframes confettiFall {
            to {
                transform: translateY(100vh) rotate(720deg);
            }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    `;
    
    try {
        document.head.appendChild(style);
    } catch (error) {
        console.warn('Could not add celebration styles:', error);
    }
}
