/**
 * Handles any resource change triggered by a card
 */
export async function handleCardResourceEffect({
  fromPlayer,
  toPlayer = null,
  resourceType,
  amount,
  source = 'cardEffect'
}) {
  console.log('=============handleCardResourceEffect=============');
  console.log(`Processing card resource effect: ${resourceType} ${amount} from ${fromPlayer.name} to ${toPlayer?.name ?? 'no target'}`);
  
  if (!isValidResource(resourceType)) {
    console.error(`Invalid resource type in card effect: ${resourceType}`);
    return;
  }

  if (toPlayer) {
    // This is a steal - subtract from fromPlayer, add to toPlayer
    console.log(`Transferring ${amount} ${resourceType} from ${fromPlayer.name} to ${toPlayer.name}`);
    
    // Calculate actual amounts with resistance/multipliers
    const resistance = getResistanceRate(fromPlayer, resourceType);
    const actualLoss = Math.floor(amount * resistance);
    
    const multiplier = getMultiplier(resourceType, true);
    const actualGain = Math.floor(amount * multiplier);
    
    // FIXED: Pass correct parameters to updatePlayerResources
    updatePlayerResources(fromPlayer.id, { [resourceType]: -actualLoss });
    updatePlayerResources(toPlayer.id, { [resourceType]: actualGain });
    
    console.log(`Transfer complete: ${fromPlayer.name} lost ${actualLoss}, ${toPlayer.name} gained ${actualGain}`);
  } else {
    // Regular resource change
    try {
      console.log(`Updating ${fromPlayer.name}'s resources: +${amount} ${resourceType}`);
      // FIXED: Pass correct parameters
      updatePlayerResources(fromPlayer.id, { [resourceType]: amount });
      console.log('Successfully updated player resources');
      
      // Call processAgeCardEffects for validation
      const currentCard = window.currentCard;
      if (currentCard) {
        console.log('Calling processAgeCardEffects for validation');
        await processAgeCardEffects(currentCard, []);
      }
    } catch (error) {
      console.error('Error in updatePlayerResources or processAgeCardEffects:', error);
    }
  }
}

export async function applyResourceChange(resourceType, amount, source, playerId) {
  console.log('=============applyResourceChange=============')
  
  const player = getCurrentPlayer(playerId);
  if (!player) {
    console.error('applyResourceChange: No current player found');
    return null;
  }
  
  console.log(`[RESOURCE] Starting chain: applyResourceChange → getMultiplier → getResistanceRate → handleCardResourceEffect`);
  console.log('Parameters:', { resourceType, amount, source });

  if (!resourceType || typeof amount !== 'number' || typeof source !== 'string') {
    console.error(`Invalid parameters for applyResourceChange:`, { resourceType, amount, source });
    return null;
  }

  // FIXED: Use consistent resource type validation
  const RESOURCE_TYPES = ['knowledge', 'money', 'influence'];
  if (!RESOURCE_TYPES.includes(resourceType)) {
    console.warn(`Unknown resource type: ${resourceType}`);
    return null;
  }

  // Get current resources for logging (before changes)
  const currentResources = player.resources || {};
  const previousValue = currentResources[resourceType] || 0;

  // Step 1: Get multiplier (this calls getMultiplier)
  const isGain = amount > 0;
  const multiplier = await getMultiplier(resourceType, isGain);
  
  // Step 2: Get resistance rate (this calls getResistanceRate) 
  const resistance = await getResistanceRate(player, resourceType);
  
  // Step 3: Apply both multiplier and resistance
  let adjustedAmount = amount;
  if (isGain) {
    adjustedAmount = Math.round(amount * multiplier);
  } else {
    adjustedAmount = Math.round(amount * resistance);
  }
  
  // Step 4: Call handleCardResourceEffect to finalize the change
  await handleCardResourceEffect({
    fromPlayer: player,
    toPlayer: null,
    resourceType: resourceType,
    amount: adjustedAmount,
    source: source
  });
  
  // FIXED: Get updated player data after changes
  const updatedPlayer = getCurrentPlayer(playerId);
  const updatedResources = updatedPlayer?.resources || {};
  const newValue = updatedResources[resourceType] || 0;
  
  const logEntry = {
    timestamp: new Date().toISOString(),
    playerId: player.id,
    playerName: player.name,
    playerRole: player.role,
    resourceType,
    originalAmount: amount,
    finalAmount: adjustedAmount,
    multiplierApplied: multiplier,
    multiplierType: isGain ? 'gain' : 'resistance',
    previousValue,
    newValue,
    source,
    isGain
  };

  // Check if resourceLog exists before using it
  if (typeof resourceLog !== 'undefined' && Array.isArray(resourceLog)) {
    resourceLog.push(logEntry);
  }

  console.group(`[RESOURCE] ${player.name} (${player.role}) - ${resourceType} Change`);
  console.log('=== TRANSACTION DETAILS ===');
  console.log('Source:', source);
  console.log('Original Amount:', amount);
  console.log('Multiplier Type:', isGain ? 'gain' : 'resistance');
  console.log('Multiplier Applied:', multiplier);
  if (multiplier !== 1) {
    console.log(`Applied ${isGain ? 'gain' : 'resistance'} multiplier: ${multiplier}x`);
  }
  console.log('Final Amount After Multipliers:', adjustedAmount);
  console.log('Previous Value:', previousValue);
  console.log('New Value:', newValue);
  console.log('=== RESOURCE STATE ===');
  console.log('All Resources After Update:', JSON.parse(JSON.stringify(updatedResources)));
  console.groupEnd();

  if (typeof logEvent === 'function') {
    logEvent(logEntry);
  }

  console.log(`[RESOURCE] Chain completed: ${player.name} ${isGain ? 'gained' : 'lost'} ${Math.abs(adjustedAmount)} ${resourceType}`);
  console.log('=============applyResourceChange END=============');

  return logEntry;
}

/**
 * Applies the effects listed on the current card to the target player(s).
 * Called for regular cards. Calls processEndPlayerTurn when complete.
 * @param {Object} card - The card to apply effects from
 */
export function applyCardEffect(card) {
  updateGameState({ currentPhase: 'PLAYING' });
  if (!isActionAllowed('AWAITING_PATH_CHOICE', 'ROLLING', 'TURN_TRANSITION')) return;
  console.log('=============applyCardEffect=============');
  console.log('Full card object received:', JSON.stringify(card, null, 2));

  const player = getCurrentPlayer();

  if (!player) {
    console.error('No current player found');
    return;
  }
    
  if (!card || !player) {
    console.warn(`Cannot apply effects of card "${card?.name}" to player ${player?.name} - card or player is undefined`);
    return;
  }

  console.log(`Applying effects of card "${card.name}" to player ${player.name}...`);
  
  // Handle different effect formats
  if (!card.effects) {
    console.error(`Card "${card.name}" has no effects property.`);
    return;
  }
  
  // Case 1: Effects organized by role (object with role keys)
  if (typeof card.effects === 'object' && !Array.isArray(card.effects)) {
    console.log(`Card "${card.name}" has role-based effects structure.`);
    
    // Try different case formats to match card data
    const rolesToTry = [
      player.role.toUpperCase(),           // HISTORIAN
      player.role.charAt(0).toUpperCase() + player.role.slice(1).toLowerCase(), // Historian
      player.role.toLowerCase()            // historian
    ];
    
    let roleEffects = null;
    let matchedRole = null;
    
    for (const roleFormat of rolesToTry) {
      if (card.effects[roleFormat]) {
        roleEffects = card.effects[roleFormat];
        matchedRole = roleFormat;
        break;
      }
    }
    
    if (roleEffects) {
      console.log(`Applying ${player.role}-specific effects (matched as "${matchedRole}"):`, roleEffects);
      
      // Process the effect
      if (Array.isArray(roleEffects)) {
        roleEffects.forEach(effect => processCardEffects(effect, player));
      } else if (typeof roleEffects === 'object') {
        processCardEffects(roleEffects, player);
      }
    } else {
      console.warn(`No effects found for role "${player.role}" on card "${card.name}"`);
      console.log('Available roles:', Object.keys(card.effects));
      
      // Check if there's a generic "ALL" key for effects that apply to all roles
      if (card.effects.ALL) {
        const allEffects = card.effects.ALL;
        if (Array.isArray(allEffects)) {
          allEffects.forEach(effect => processCardEffects(effect, player));
        } else {
          processCardEffects(allEffects, player);
        }
      }
    }
    
    updateGameState({ currentPhase: 'PLAYING' });
    console.warn('game phase updated to PLAYING');
    // Call processEndPlayerTurn after applying effects
    console.log('=============applyCardEffect END=============');
    processEndPlayerTurn();
    return;
  }
  
  // Case 2: Effects as an array (original format)
  if (Array.isArray(card.effects)) {
    card.effects.forEach(effect => processCardEffects(effect, player));
    
    // Call processEndPlayerTurn after applying effects
    console.log('=============applyCardEffect END=============');
    processEndPlayerTurn();
    return;
  }
  
  // If we get here, the effects property has an unexpected format
  console.log(`Card "${card.name}" effects has an unexpected format:`, card.effects);
  
  // Call processEndPlayerTurn even if effects format is unexpected
  console.log('=============applyCardEffect END=============');
  processEndPlayerTurn();
}

export async function applyAgeCardEffect(card, optionName = null, playerId) {
  if (!isActionAllowed('AWAITING_PATH_CHOICE', 'ROLLING', 'TURN_TRANSITION')) return;
  updateGameState({ currentPhase: 'PLAYING' });
  console.log('=============applyAgeCardEffect=============')
  console.log('Card:', card.name);
  console.log('Option:', optionName);
  
  const player = getCurrentPlayer(playerId);
  if (!player) {
    console.error('No current player found');
    return;
  }
  
  let effects;
  
  if (optionName) {
    effects = card.choice?.[optionName]?.effects;
    if (!effects || !Array.isArray(effects)) {
      console.warn(`No effects array found for option ${optionName}:`, card.choice?.[optionName]);
      console.log('=============applyAgeCardEffect END=============')
      await processAgeCardEffects(card, []);
      return;
    }
  } else {
    effects = card.effects;
    if (!effects || !Array.isArray(effects)) {
      console.warn('No effects array found on card:', card);
      console.log('=============applyAgeCardEffect END=============')
      await processAgeCardEffects(card, []);
      return;
    }
  }
  
  console.log(`Starting sequential processing of ${effects.length} effects`);
  
  // Process all effects sequentially with proper async/await chains
  for (const effect of effects) {
    try {
      console.log('Processing effect:', effect);
      
      // Handle different effect types with proper async chains
      switch (effect.type) {
        case 'RESOURCE_CHANGE': {
          const player = getCurrentPlayer(playerId);
          if (!player) {
            console.error('No current player found during RESOURCE_CHANGE');
            break;
          }
        
          if (effect.changes && typeof effect.changes === 'object') {
            for (const [resourceType, amount] of Object.entries(effect.changes)) {
              if (typeof amount === 'number') {
                await applyResourceChange(resourceType, amount, 'cardEffect', player.id);
              }
            }
          } else if (effect.resource && typeof effect.amount === 'number') {
            await applyResourceChange(effect.resource, effect.amount, 'cardEffect', player.id);
          } else {
            console.warn('Invalid RESOURCE_CHANGE effect:', effect);
          }
          break;
        }
        
        case 'MOVEMENT':
        case 'MOVE_TO':
          await handleCardMovement(effect);
          break;
          
        case 'SKIP_TURN':
          // Handle both old format (effect.turns) and age card format (effect.target)
          const skipEffect = {
            turns: effect.turns || 1, // Default to 1 turn if not specified
            target: effect.target || 'SELF'
          };
          await applySkipTurn(skipEffect, player);
          break;
          
        case 'STEAL':
          // Normalize age card STEAL effect format to work with existing functions
          const normalizedStealEffect = {
            type: 'STEAL',
            resource: effect.resource ? effect.resource.toLowerCase() : 'money', // Convert MONEY → money
            amount: effect.amount || 1,
            target: effect.target || 'OTHER'
          };
          // Start proper steal chain: applyStealEffect → getValidStealTargets → showStealPopover → handleStealEffect
          await applyStealEffect(normalizedStealEffect, player);
          break;

        case 'STEAL_FROM_ALL':
          await handleStealFromAll(effect, player, getPlayers());
          break;
          
        default:
          // For any other effect type, use processCardEffects
          await processCardEffects(effect, player);
      }
    } catch (error) {
      console.error('Error processing effect:', effect, error);
    }
  }

  console.log('All effects completed - calling processAgeCardEffects');
  // Validate and finalize all effects
  await processAgeCardEffects(card, effects);
}

/**
 * Update a player's resources in global state
 * @param {string} playerId - The ID of the player to update
 * @param {Object} changes - The resource changes to apply (can be positive or negative)
 * @returns {boolean} - True if update succeeded, false otherwise
 */
export function updatePlayerResources(playerId, changes) {
  console.log('=============updatePlayerResources=============');
  console.log('Input parameters:', { playerId, changes });
  
  // FIXED: Validate input parameters
  if (!playerId || typeof playerId !== 'string') {
    console.error('Invalid playerId parameter:', playerId);
    return false;
  }
  
  if (!changes || typeof changes !== 'object') {
    console.error('Invalid changes parameter:', changes);
    return false;
  }
  
  // Find the player in the global state
  const players = getPlayers ? getPlayers() : []; // Safety check
  const player = players.find(p => p.id === playerId);
  
  if (!player) {
    console.error('Player not found with ID:', playerId);
    console.log('Available players:', players.map(p => ({ id: p.id, name: p.name })));
    return false;
  }

  // Validate player has resources object
  if (!player.resources) {
    console.warn('Player missing resources object, initializing:', player.name);
    player.resources = { knowledge: 0, money: 0, influence: 0 };
  }

  // Define valid resources
  const RESOURCES = ['knowledge', 'money', 'influence'];

  // Validate and normalize changes
  const normalizedChanges = {};
  let isValid = true;
  
  for (const resource in changes) {
    if (!RESOURCES.includes(resource)) {
      console.warn(`Invalid resource type '${resource}' ignored`);
      continue;
    }

    const change = Number(changes[resource]);
    if (isNaN(change)) {
      console.error(`Invalid change value for ${resource}:`, changes[resource]);
      isValid = false;
      break;
    }

    normalizedChanges[resource] = change;
  }

  if (!isValid || Object.keys(normalizedChanges).length === 0) {
    console.error('No valid changes to apply');
    return false;
  }

  // Calculate new values first to ensure all changes are valid
  const newValues = { ...player.resources };
  for (const [resource, change] of Object.entries(normalizedChanges)) {
    const currentValue = newValues[resource] || 0;
    const newValue = currentValue + change;

    // Prevent negative resources
    if (newValue < 0) {
      console.error(`Cannot update ${resource}: would result in negative value (${newValue})`);
      return false;
    }

    newValues[resource] = newValue;
  }

  // Apply validated changes to the player object
  Object.assign(player.resources, newValues);
  console.log(`Resources updated for ${player.name}:`, player.resources);

  // Update the global state with the modified player
  const updatedPlayers = players.map(p => 
    p.id === playerId ? { ...p, resources: { ...player.resources } } : p
  );
  
  // Update global state (if function exists)
  if (typeof updateGameState === 'function') {
    updateGameState({ players: updatedPlayers });
  }
  
  // Notify subscribers of state changes (if function exists)
  if (typeof notifySubscribers === 'function') {
    notifySubscribers();
  }

  // Trigger UI update for this specific player (if function exists)
  if (typeof updatePlayerInfo === 'function') {
    updatePlayerInfo(playerId);
  }
  
  console.log('=============updatePlayerResources END=============');
  return true;
}
