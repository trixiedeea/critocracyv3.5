
/**
 * Process a single effect, handling immunity and applying the correct effect type
 * @param {object} effect - The effect object from the card.
 * @param {object} player - The target player of the effect.
 * @param {object} sourcePlayer - The player who initiated the effect (drew the card).
 */
export function applyAgeCardEffect(effect, player, sourcePlayer) {
    console.log(` Processing effect: ${JSON.stringify(effect)} for target ${player.name} from source ${sourcePlayer.name}`);
    
    // Define the target player based on the effect's target property if it exists
    let targetPlayer = player; // Default target is the player passed in (often source player)
    if (effect.target === 'OTHER') {
        targetPlayer = getRandomOtherPlayer(sourcePlayer);
        if (!targetPlayer) {
            console.log(`Effect targeted OTHER, but no other player found.`);
            return; // Cannot apply effect if no target
        }
        console.log(` Effect target is OTHER: ${targetPlayer.name}`);
        // For effects targeting others, the 'player' arg might be misleading, use targetPlayer
    } else if (effect.target === 'SELF') {
        targetPlayer = sourcePlayer; // Explicitly target the source player
        console.log(` Effect target is SELF: ${targetPlayer.name}`);
    } 
    // If no target property, assume the effect applies to the sourcePlayer (player who drew card)
    else if (!effect.target) {
         targetPlayer = sourcePlayer;
    } 
    // Note: Some functions below might re-determine the target internally based on convention

    // Check for immunity BEFORE applying effect
    // Always check immunity of the ACTUAL target player against the source player
    if (hasImmunity(targetPlayer, effect.type, sourcePlayer)) { 
        console.log(` Player ${targetPlayer.name} is immune to ${effect.type} from ${sourcePlayer.name}.`);
        return; // Skip this effect
    }
    
    // Apply the effect based on its type
    switch (effect.type) {
        case 'RESOURCE_CHANGE':
            // Applies to the player object passed in (usually the source) unless target logic modifies it
            updatePlayerResources(effect, targetPlayer); 
            break;
        case 'MOVEMENT':
            // applyMovement determines target internally based on effect.target
            handleCardMovement(effect, sourcePlayer); 
            break;
        case 'STEAL':
             // Source player steals from the target player
             applySteal(effect, targetPlayer, sourcePlayer);
             break;
        case 'SKIP_TURN':
             // applySkipTurn determines target internally based on effect.target
             applySkipTurn(effect, sourcePlayer);
             break;
        case 'STEAL_FROM_ALL':
             // Source player steals from all others
             applyStealFromAll(effect, sourcePlayer);
             break;
        default:
            console.warn(`Unknown card effect type: ${effect.type}`);
            if (!player.isHuman) {
                updatePlayerResources(effect, player);
                handleEndTurn();
            } else {
                updatePlayerResources(effect, player);
                handleEndTurn();
            }
            break;
    }
};

// Helper function to format resource changes
function formatResourceChanges(changes) {
    if (!changes) return '';
    
    const changesList = [];
    if (changes.money !== undefined) {
        changesList.push(`${changes.money >= 0 ? '+' : ''}${changes.money} Money`);
    }
    if (changes.knowledge !== undefined) {
        changesList.push(`${changes.knowledge >= 0 ? '+' : ''}${changes.knowledge} Knowledge`);
    }
    if (changes.influence !== undefined) {
        changesList.push(`${changes.influence >= 0 ? '+' : ''}${changes.influence} Influence`);
    }
    return changesList.join(', ');
};

// Helper function to format a single effect
function formatEffect(effect) {
    if (!effect) return '';
    
    // Handle different effect types
    switch(effect.type) {
        case 'RESOURCE_CHANGE':
        case 'RESOURCE':
            const changes = effect.changes ? formatResourceChanges(effect.changes) : '';
            return `${effect.description || 'Resource change'}: ${changes}`;
            
        case 'MOVEMENT':
        case 'MOVE':
            const spaces = effect.spaces || 'some';
            const direction = effect.direction ? ` ${effect.direction}` : '';
            const target = effect.target && effect.target !== 'SELF' ? ` (${effect.target})` : '';
            return `Move${direction} ${spaces} spaces${target}`;
            
        case 'STEAL':
            const amount = effect.amount || 'some';
            const resource = effect.resource || 'resources';
            const from = effect.target ? ` from ${effect.target}` : '';
            return `Steal ${amount} ${resource}${from}`;
            
        case 'SKIP_TURN':
            return `Skip ${effect.target || 'your'} next turn`;
            
        case 'DRAW_CARD':
            const count = effect.count || 1;
            return `Draw ${count} card${count !== 1 ? 's' : ''}`;
            
        case 'CHANGE_PATH':
        case 'PATH_CHANGE':
            return `Change path to ${effect.path || 'a new path'}`;
            
        default:
            // If we have a description, use that
            if (effect.description) return effect.description;
            // If we have an effect property, use that
            if (effect.effect) return effect.effect;
            // As a last resort, show the raw effect
            return JSON.stringify(effect);
    }
};

/**
 * Process a single effect, handling immunity and applying the correct effect type
 * @param {object} effect - The effect object from the card.
 * @param {object} player - The target player of the effect.
 * @param {object} sourcePlayer - The player who initiated the effect (drew the card).
 */
function processEffect(effect, player, sourcePlayer) {
    console.log('---------processEffect---------');
    console.log(` Processing effect: ${JSON.stringify(effect)} for target ${player.name} from source ${sourcePlayer.name}`);
    
    // Define the target player based on the effect's target property if it exists
    let targetPlayer = player; // Default target is the player passed in (often source player)
    if (effect.target === 'OTHER') {
        targetPlayer = getRandomOtherPlayer(sourcePlayer);
        if (!targetPlayer) {
            console.log(`Effect targeted OTHER, but no other player found.`);
            return; // Cannot apply effect if no target
        }
        console.log(` Effect target is OTHER: ${targetPlayer.name}`);
        // For effects targeting others, the 'player' arg might be misleading, use targetPlayer
    } else if (effect.target === 'SELF') {
        targetPlayer = sourcePlayer; // Explicitly target the source player
        console.log(` Effect target is SELF: ${targetPlayer.name}`);
    } 
    // If no target property, assume the effect applies to the sourcePlayer (player who drew card)
    else if (!effect.target) {
         targetPlayer = sourcePlayer;
    } 
    // Note: Some functions below might re-determine the target internally based on convention

    // Check for immunity BEFORE applying effect
    // Always check immunity of the ACTUAL target player against the source player
    if (hasImmunity(targetPlayer, effect.type, sourcePlayer)) { 
        console.log(` Player ${targetPlayer.name} is immune to ${effect.type} from ${sourcePlayer.name}.`);
        return; // Skip this effect
    }
    
    // Apply the effect based on its type
    switch (effect.type) {
        case 'RESOURCE_CHANGE':
            // Applies to the player object passed in (usually the source) unless target logic modifies it
            applyResourceChange(effect, targetPlayer); 
            break;
        case 'MOVEMENT':
            // applyMovement determines target internally based on effect.target
            applyMovement(effect, sourcePlayer); 
            break;
        case 'STEAL':
            case 'STEAL':
                // delay steal for player interaction
                if (sourcePlayer.isAI) {
                  const validTargets = getValidStealTargets(sourcePlayer, getPlayers(), effect);
                  const target = getRandom(validTargets);
                  const rate = getResistanceRate(target, effect.resource);
                  applyStealEffect(effect, target, sourcePlayer, Math.floor(effect.amount * rate));
                } else {
                  showStealPopover(effect, sourcePlayer, getPlayers());
                }
                break;
        case 'SKIP_TURN':
             // applySkipTurn determines target internally based on effect.target
             applySkipTurn(effect, sourcePlayer);
             break;
        case 'CHANGE_PATH':

        case 'DRAW_CARD':
            // Source player draws a card
            applyDrawCard(effect, sourcePlayer);
            break;
        case 'STEAL_FROM_ALL':
            handleStealFromAll(effect, sourcePlayer, getPlayers());
            break;
        default:
            console.warn(`Unknown card effect type: ${effect.type}`);
    }
};

// ===== Effect Processing Functions =======


function applyResourceChange(effect, player) {
    console.log('---------applyResourceChange---------');
    console.log(` Applying RESOURCE_CHANGE to ${player.name}:`, effect.changes);
    // effect.changes should be an object like { knowledge: 10, money: -5 }
    updatePlayerResources(effect, player);
    updateResourcePanel(player); 
};

function applyMovement(effect, player) {
    // player here is the sourcePlayer passed from processEffect
    console.log(` Processing MOVEMENT effect initiated by ${player.name}:`, effect);

    let targetPlayerForMove = null;
    if (effect.target === 'SELF') {
        targetPlayerForMove = player;
    } else if (effect.target === 'OTHER') {
        targetPlayerForMove = getRandomOtherPlayer(player);
        if (!targetPlayerForMove) {
            console.log("No other player found for MOVEMENT effect.");
            return; 
        }
        console.log(` Target for movement effect is other player: ${targetPlayerForMove.name}`);
    } else {
        // If target is not specified, assume SELF
        targetPlayerForMove = player; 
    }
    
    // Pass the responsibility to game.js
    handleCardMovement(targetPlayerForMove, effect);
};


function applySkipTurn(effect, player) {
    // player here is the sourcePlayer passed from processEffect
    console.log(` Processing SKIP_TURN initiated by ${player.name}:`, effect);
    let target = null;
    if (effect.target === 'SELF') {
        target = player;
    } else if (effect.target === 'OTHER') {
         target = getRandomOtherPlayer(player);
    } else {
         // If target is not specified, assume SELF
         target = player; 
    }
    
    if (!target) {
         console.log("No target found for SKIP_TURN effect.");
         return;
    }
    
    // Check target's immunity (source is the player who drew the card)
    // Pass the original initiator (player) as source for immunity check
    if (hasImmunity(target, 'SKIP_TURN', player)) { 
         console.log(` Target ${target.name} is immune to SKIP_TURN.`);
         return;
    }
    
    console.log(` Player ${target.name} will skip their next turn.`);
    setPlayerSkipTurn(target, true); 
};


export function updatePlayerResources(player, changes) {
    if (!player || !changes) {
        console.error('Invalid parameters for updatePlayerResources:', { player, changes });
        return false;
    }
    
    // Validate player has resources object
    if (!player.resources) {
        console.error('Player missing resources object:', player);
        return false;
    }

    // Validate and normalize changes
    const normalizedChanges = {};
    let isValid = true;
    for (const resource in changes) {
        if (!RESOURCES.includes(resource)) {
            console.warn(`Invalid resource type '${resource}' ignored`);
            continue;
        }
        
        const change = Number(changes[resource]);
        if (isNaN(change)) {
            console.error(`Invalid change value for ${resource}:`, changes[resource]);
            isValid = false;
            break;
        }
        
        normalizedChanges[resource] = change;
    }
    
    if (!isValid) return false;

    // Calculate new values first to ensure all changes are valid
    const newValues = { ...player.resources };
    for (const [resource, change] of Object.entries(normalizedChanges)) {
        const currentValue = newValues[resource] || 0;
        const newValue = currentValue + change;
        
        // Prevent negative resources
        if (newValue < 0) {
            console.error(`Cannot update ${resource}: would result in negative value (${newValue})`);
            return false;
        }
        
        newValues[resource] = newValue;
    }

    // Apply validated changes
    Object.assign(player.resources, newValues);
    console.log(`Resources updated for ${player.name}:`, player.resources);
    
    // Trigger UI update
    updatePlayerInfo();
    return true;
}

/**
 * Update player's resource panel with current values.
 * Expected HTML structure:
 * <div id="player-resource-panel-p1">
 *   <span class="player-name">Alice</span>
 *   <span class="money">üí∞ 10</span>
 *   <span class="knowledge">üìö 5</span>
 *   <span class="influence">üó≥Ô∏è 3</span>
 *   <div class="resource-feedback"></div>
 * </div>
 */
export function updateResourcePanel(player) {
    console.log('---------updateResourcePanel---------');
    const panel = document.getElementById(`player-resource-panel-${player.id}`);
    if (!panel) {
      console.error(`No resource panel found for player ID: ${player.id}`);
      return;
    }
  
    panel.querySelector('.player-n').textContent = player.name;
    panel.querySelector('.money').textContent = `üí∞ ${player.resources.money}`;
    panel.querySelector('.knowledge').textContent = `üìö ${player.resources.knowledge}`;
    panel.querySelector('.influence').textContent = `üó≥Ô∏è ${player.resources.influence}`;
};
  
  /**
   * Flash a feedback animation near the resource panel for the player
   */
export function showResourceChangeFeedback(playerId, resourceType, amount) {
    console.log('---------showResourceChangeFeedback---------');
    const panel = document.getElementById(`player-resource-panel-${playerId}`);
    if (!panel) return;
  
    const feedbackEl = panel.querySelector('.resource-feedback');
    if (!feedbackEl) return;
  
    const sign = amount > 0 ? '+' : '';
    const emoji = {
      money: 'üí∞',
      knowledge: 'üìö',
      influence: 'üó≥Ô∏è'
    }[resourceType] || '';
  
    feedbackEl.textContent = `${emoji} ${sign}${amount}`;
    feedbackEl.style.opacity = '1';
    feedbackEl.style.transform = 'translateY(-10px)';
    feedbackEl.style.transition = 'all 0.6s ease';
  
    // Fade out after a moment
    setTimeout(() => {
      feedbackEl.style.opacity = '0';
      feedbackEl.style.transform = 'translateY(0px)';
    }, 1000);
}