


/* State Management Issues:
_state.player (template object) is being confused with _state.game.players 
(actual player data)
Resources are stored in both player.resources and _state.playerResources
Resource Display Issues:
The display code in 
updateResourceDisplays
 assumes resources are in player.resources
Some code might still be updating _state.playerResources instead
End Game Issues:
Final scores aren't being calculated correctly because resources aren't 
being tracked consistently
Proposed Fixes:
Unify Resource Storage:
Choose one location to store resources (preferably directly in player objects)
Update all resource-related functions to use this single source
Update Resource Display:
Modify 
updateResourceDisplays
 to use the correct resource location
Ensure all resource updates trigger a display update
Fix End Game Calculation:
Make sure final resource totals are calculated from the correct source
Update the end game screen to display the correct values
Would you like me to start implementing these fixes? I can begin with the most critical issue first.

Feedback submitted
Close
2 days ago
17 hours ago
15 minutes ago
Press Enter again to interrupt and send a new message


Here's a summary of where player resources are being used:

player.resources is used in:
ui.js:
Updates UI display of resources
Shows knowledge, money, and influence counts
resourceManagement.js:
Main resource handling logic
Updates and tracks resource values
Handles resource changes and calculations
players.js:
Player creation and management
Debug logging of resources
Resource initialization and updates
state.playerResources is used in:
state.js:
Storage of player resources by ID
Part of the main state management
resourceManagement.js:
getPlayerResources()
 function
Fallback for resource lookups
players.js:
getPlayerResources()
 function
Resource initialization
Key Issues:
Dual Storage:
Resources are stored in both player.resources and state.playerResources
This can lead to synchronization issues
Inconsistent Access:
Some code uses player.resources directly
Other code uses 
getPlayerResources()
State Management:
_state.player was removed, but some code might still reference it
Need to ensure all code uses _state.game.players
Recommendation:
Choose One Storage Method:
Prefer player.resources for direct access
Remove state.playerResources entirely
Update All References:
Replace 
getPlayerResources()
 with direct player.resources access
Ensure all resource updates go through a single function
Test Thoroughly:
Resource updates
UI display
End game calculations

In state.js:
Update the 
updatePlayerResources
 function to use the new structure:
javascript
export function updatePlayerResources(playerId, resources) {
    _state.player.resources[playerId] = JSON.parse(JSON.stringify(resources));
    notifySubscribers();
}
In ui.js:
updateResourceDisplayContainer
 function needs to use the new path:
javascript
panelUpdated.querySelector('.KNOWLEDGE_COUNT').textContent = `Knowledge ${player.resources.money}`;
panelUpdated.querySelector('.MONEY_COUNT').textContent = `Money ${player.resources.knowledge}`;
panelUpdated.querySelector('.INFLUENCE_COUNT').textContent = `Influence ${player.resources.influence}`;
In resourceManagement.js:
handleStealEffect
 needs to be updated to use the new path:
javascript
const targetResources = state.player.resources[targetPlayer.id] || {};
In players.js:
getPlayerScore
 function (commented out but should be updated if used):
javascript
// score += Object.values(state.player.resources[player.id] || {}).reduce((sum, val) => sum + val, 0);
In cards.js:
Any direct resource access should be updated to use the new path through state.player.resources[playerId]
The main changes involve:

Replacing direct player.resources access with state.player.resources[playerId]
Updating any functions that modify resources to use the new centralized state
Ensuring all resource reads go through the state object
Would you like me to help implement any of these changes? I can make the updates systematically to ensure everything works correctly with the new state structure.
*/

/*import { notifySubscribers } from "./state";

// ---- Local helpers to keep this module self-consistent ----
// Canonical resource types used across this file
const RESOURCE_TYPES = ['knowledge', 'money', 'influence'];

function isValidResource(type) {
  return RESOURCE_TYPES.includes(type);
}

// Safe defaults if external modifiers are not wired yet
async function getMultiplier(resourceType, isGain = true) {
  // If a global implementation exists, use it
  if (typeof window !== 'undefined' && typeof window.getMultiplier === 'function') {
    return window.getMultiplier(resourceType, isGain);
  }
  if (typeof getMultiplierGlobal === 'function') {
    return getMultiplierGlobal(resourceType, isGain);
  }
  return 1; // default: no multiplier
}

async function getResistanceRate(player, resourceType) {
  if (typeof window !== 'undefined' && typeof window.getResistanceRate === 'function') {
    return window.getResistanceRate(player, resourceType);
  }
  if (typeof getResistanceRateGlobal === 'function') {
    return getResistanceRateGlobal(player, resourceType);
  }
  return 1; // default: no resistance
}

export function applyCardEffect(card) {
  updateGameState({ currentPhase: 'PLAYING' });
  if (!isActionAllowed('AWAITING_PATH_CHOICE', 'ROLLING', 'TURN_TRANSITION')) return;
  console.log('=============applyCardEffect=============');
  //console.log('Full card object received:', JSON.stringify(card, null, 2));

  const player = getCurrentPlayer();

  if (!player) {
    console.error('No current player found');
    return;
}
    
  if (!card || !player) {
      console.warn(`Cannot apply effects of card "${card.name}" to player ${player.name} card or player is undefined`);
      return;
  }

  //console.log(`Applying effects of card "${card.name}" to player ${player.name}...`);
  
  // Handle different effect formats
  if (!card.effects) {
      console.error(`Card "${card.name}" has no effects property.`);
      return;
  }
  
  // Case 1: Effects organized by role (object with role keys)
  if (typeof card.effects === 'object' && !Array.isArray(card.effects)) {
    //console.log(`Card "${card.name}" has role-based effects structure.`);
    
    // REPLACE THIS ENTIRE SECTION WITH OPTION 2:
    // Try different case formats to match card data
    const rolesToTry = [
        player.role.toUpperCase(),           // HISTORIAN
        player.role.charAt(0).toUpperCase() + player.role.slice(1).toLowerCase(), // Historian
        player.role.toLowerCase()            // historian
    ];
    
    let roleEffects = null;
    let matchedRole = null;
    
    for (const roleFormat of rolesToTry) {
        if (card.effects[roleFormat]) {
            roleEffects = card.effects[roleFormat];
            matchedRole = roleFormat;
            break;
        }
    }
    
    if (roleEffects) {
        console.log(`Applying ${player.role}-specific effects (matched as "${matchedRole}"):`, roleEffects);
        
        // Process the effect
        if (Array.isArray(roleEffects)) {
            roleEffects.forEach(effect => processCardEffects(effect, player));
        } else if (typeof roleEffects === 'object') {
            processCardEffects(roleEffects, player, player);
        }
    } else {
        console.warn(`No effects found for role "${player.role}" on card "${card.name}"`);
        //console.log('Available roles:', Object.keys(card.effects));
        
        // Check if there's a generic "ALL" key for effects that apply to all roles
        if (card.effects.ALL) {
            const allEffects = card.effects.ALL;
            if (Array.isArray(allEffects)) {
                allEffects.forEach(effect => processCardEffects(effect, player));
            } else {
                processCardEffects(allEffects, player);
            }
        }
    }
    updateGameState({
        currentPhase: 'PLAYING',
    });
    console.warn('game phase updated to PLAYING');
      // Call processEndPlayerTurn after applying effects
      console.log('=============applyCardEffect END=============');
      processEndPlayerTurn();
      return;
  }
  
  // Case 2: Effects as an array (original format)
  if (Array.isArray(card.effects)) {
      card.effects.forEach(effect => processCardEffects(effect, player));
      
      // Call processEndPlayerTurn after applying effects
      console.log('=============applyCardEffect END=============');
      processEndPlayerTurn();
      return;
  }
  
  // If we get here, the effects property has an unexpected format
  //console.log(`Card "${card.name}" effects has an unexpected format:`, card.effects);
  
  // Call processEndPlayerTurn even if effects format is unexpected
  console.log('=============applyCardEffect END=============');
  processEndPlayerTurn();
};

export async function applyAgeCardEffect(card, optionName = null, playerId) {
  if (!isActionAllowed('AWAITING_PATH_CHOICE', 'ROLLING', 'TURN_TRANSITION')) return;
  updateGameState({ currentPhase: 'PLAYING' });
  console.log('=============applyAgeCardEffect=============')
  //console.log('Card:', card.name);
  //console.log('Option:', optionName);
  
  const player = getCurrentPlayer();
  if (!player) {
    console.error('No current player found');
    return;
  }
  
  let effects;
  
  if (optionName) {
    effects = card.choice?.[optionName]?.effects;
    if (!effects || !Array.isArray(effects)) {
      console.warn(`No effects array found for option ${optionName}:`, card.choice?.[optionName]);
      console.log('=============applyAgeCardEffect END=============')
      await processAgeCardEffects(card, []);
      return;
    }
  } else {
    effects = card.effects;
    if (!effects || !Array.isArray(effects)) {
      console.warn('No effects array found on card:', card);
      console.log('=============applyAgeCardEffect END=============')
      await processAgeCardEffects(card, []);
      return;
    }
  }
  
  //console.log(`Starting sequential processing of ${effects.length} effects`);
  
  // Process all effects sequentially with proper async/await chains
  for (const effect of effects) {
    try {
      //console.log('Processing effect:', effect);
      
      // Handle different effect types with proper async chains
      switch (effect.type) {
        case 'RESOURCE_CHANGE': {
          const player = getCurrentPlayer();
          if (!player) {
            console.error('No current player found during RESOURCE_CHANGE');
            break;
          }
        
          if (effect.changes && typeof effect.changes === 'object') {
            for (const [resourceType, amount] of Object.entries(effect.changes)) {
              if (typeof amount === 'number') {
                await applyResourceChange(resourceType, amount, 'cardEffect', player.id);
              }
            }
          } else if (effect.resource && typeof effect.amount === 'number') {
            await applyResourceChange(effect.resource, effect.amount, 'cardEffect', player.id);
          } else {
            console.warn('Invalid RESOURCE_CHANGE effect:', effect);
          }
          break;
      }
        case 'MOVEMENT':
        case 'MOVE_TO':
          await handleCardMovement(effect);
          break;
          
        case 'SKIP_TURN':
          // Handle both old format (effect.turns) and age card format (effect.target)
          const skipEffect = {
            turns: effect.turns || 1, // Default to 1 turn if not specified
            target: effect.target || 'SELF'
          };
          await applySkipTurn(skipEffect, player);
          break;
          
        case 'STEAL':
          // Normalize age card STEAL effect format to work with existing functions
          const normalizedStealEffect = {
            type: 'STEAL',
            resource: effect.resource ? effect.resource.toLowerCase() : 'money', // Convert MONEY → money
            amount: effect.amount || 1,
            target: effect.target || 'OTHER'
          };
          // Start proper steal chain: applyStealEffect → getValidStealTargets → showStealPopover → handleStealEffect
          await applyStealEffect(normalizedStealEffect, player);
          break;

        case 'STEAL_FROM_ALL':
          await handleStealFromAll(effect, player, getPlayers());
          break;
          
        default:
          // For any other effect type, use processCardEffects
          await processCardEffects(effect, player);
      }
    } catch (error) {
      console.error('Error processing effect:', effect, error);
    }
  }

  //console.log('All effects completed - calling processAgeCardEffects');
  // Validate and finalize all effects
  await processAgeCardEffects(card, effects);
}

export async function applyResourceChange(resourceType, amount, source, playerId, callback = null) {
  console.log('=============applyResourceChange=============');
  
  // Get the target player
  const player = playerId ? getPlayerById(playerId) : getCurrentPlayer();
  if (!player) {
    console.error('applyResourceChange: No player found');
    return null;
  }
  
  //console.log(`[RESOURCE] Starting resource change for ${player.name} (${player.role})`);
  console.log('Parameters:', { 
    resourceType, 
    amount, 
    source,
    playerId: player.id,
    playerName: player.name
  });

  // Input validation
  if (!resourceType || typeof amount !== 'number' || typeof source !== 'string') {
    console.error('Invalid parameters for applyResourceChange:', { resourceType, amount, source });
    return null;
  }

  if (!RESOURCE_TYPES.includes(resourceType)) {
    console.error(`Unknown resource type: ${resourceType}. Valid types are:`, RESOURCE_TYPES);
    return null;
  }

  if (amount === 0) {
    //console.log('No change needed: amount is 0');
    return { success: true, amount: 0 };
  }

  try {
    // Get current resource value before any changes
    const currentValue = player.resources?.[resourceType] || 0;
    const isGain = amount > 0;
    
    console.group(`[RESOURCE] ${player.name} - Processing ${resourceType} ${isGain ? 'gain' : 'loss'}`);
    console.log('Initial Value:', currentValue);
    console.log('Requested Change:', amount);
    
    // Apply multipliers and resistances
    let adjustedAmount = amount;
    
    if (isGain) {
      // Apply gain multipliers
      const multiplier = await getMultiplier(resourceType, true);
      if (multiplier !== 1) {
        adjustedAmount = Math.round(amount * multiplier);
        //console.log(`Applied gain multiplier: ${multiplier}x`);
      }
    } else {
      // Apply resistance for losses
      const resistance = await getResistanceRate(player, resourceType);
      if (resistance !== 1) {
        adjustedAmount = Math.round(amount * resistance);
        //console.log(`Applied resistance: ${resistance}x`);
      }
    }
    
    // Ensure we don't go below zero
    if (!isGain && Math.abs(adjustedAmount) > currentValue) {
      //console.log(`Adjusting loss to not go below zero (was: ${adjustedAmount}, max: ${currentValue})`);
      adjustedAmount = -currentValue;
    }
    
    console.log('Final Change After Adjustments:', adjustedAmount);
    
    // Apply the resource change through the single source of truth
    let newValue;
    if (callback) {
      const result = await callback({
        currentPlayer: player,
        resourceType,
        amount: adjustedAmount,
        source,
        fromPlayer: source === 'steal' ? getCurrentPlayer() : null
      });
      // Ensure state is updated via unified updater
      await updatePlayerResources(player, { [resourceType]: adjustedAmount });
      newValue = (player.resources?.[resourceType] || 0) + adjustedAmount;
    } else {
      await updatePlayerResources(player, { [resourceType]: adjustedAmount });
      newValue = (player.resources?.[resourceType] || 0) + adjustedAmount;
    }
    
    // Log the complete transaction
    const logEntry = {
      timestamp: new Date().toISOString(),
      playerId: player.id,
      playerName: player.name,
      playerRole: player.role,
      resourceType,
      originalAmount: amount,
      adjustedAmount,
      previousValue: currentValue,
      newValue: newValue !== undefined ? newValue : (currentValue + adjustedAmount),
      source,
      isGain
    };
    
    resourceLog.push(logEntry);
    
    console.log('Resource Update Summary:');
    console.log('Previous Value:', currentValue);
    console.log('Change:', adjustedAmount);
    console.log('New Value:', logEntry.newValue);
    console.groupEnd();
    
    console.log(`[RESOURCE] ${player.name} ${isGain ? 'gained' : 'lost'} ${Math.abs(adjustedAmount)} ${resourceType}`);
    
    // UI updates are driven by subscribers; do not update UI directly here
    
    console.log('=============applyResourceChange END=============');
    
    return {
      success: true,
      amount: adjustedAmount,
      previousValue: currentValue,
      newValue: logEntry.newValue,
      logEntry
    };
    
  } catch (error) {
    console.error('Error in applyResourceChange:', error);
    console.groupEnd();
    
    return {
      success: false,
      error: error.message,
      resourceType,
      amount,
      source
    };
  }
}

export async function processCardEffects(card, targetPlayer = null) {
    console.log('================processCardEffects================')
    // Use provided player or get current player
    const currentPlayer = targetPlayer || getCurrentPlayer();
    
    if (!currentPlayer) {
        console.error('No current player found');
        processEndPlayerTurn(card);
        return;
    }
    
    //console.log(`Processing card effects for player ${currentPlayer.name} with role ${currentPlayer.role || 'N/A'}`);
    
    // If the card parameter is already an effect (not a card object with effects property)
    if (card && (card.type || card.changes || card.effect)) {
        //console.log('Processing direct effect:', card);
        // Handle the effect directly
        if (card.type === 'RESOURCE_CHANGE') {
            //console.log(`Applying resource change effect to ${currentPlayer.name}:`, card.changes);
            // Apply each resource change individually
            if (card.changes.money !== undefined) {
                await applyResourceChange('money', card.changes.money, 'cardEffect', currentPlayer.id);
            }
            if (card.changes.knowledge !== undefined) {
                await applyResourceChange('knowledge', card.changes.knowledge, 'cardEffect', currentPlayer.id);
            }
            if (card.changes.influence !== undefined) {
                await applyResourceChange('influence', card.changes.influence, 'cardEffect', currentPlayer.id);
            }
        } else if (card.type === 'MOVEMENT') {
            //console.log(`Applying movement effect to ${currentPlayer.name}:`, card);
            handleCardMovement(currentPlayer, card);
        } else if (card.type === 'SKIP_TURN') {
            //console.log(`Skipping turn for ${currentPlayer.name}`);
            skipPlayerTurn(currentPlayer, card.turns || 1);
        } else {
            console.warn(`Unknown effect type: ${card.type}`, card);
        }
        return;
    }
    
    // Handle case where we have a card object with effects
    if (!card.effects) {
        console.error('Card has no effects property');
        processEndPlayerTurn(card);
        return;
    }
    
    // If effects is an array, process each effect
    if (Array.isArray(card.effects)) {
        card.effects.forEach(effect => {
            if (effect.type === 'RESOURCE_CHANGE') {
                //console.log(`Applying resource change effect to ${currentPlayer.name}:`, effect.changes);
                applyResourceChange({
                    player: currentPlayer,
                    changes: effect.changes,
                    source: 'card',
                    cardId: card?.id,
                    explanation: effect.explanation
                });
            } else if (effect.type === 'MOVEMENT') {
                //console.log(`Applying movement effect to ${currentPlayer.name}:`, effect);
                handleCardMovement(currentPlayer, effect);
            } else if (effect.type === 'SKIP_TURN') {
                //console.log(`Skipping turn for ${currentPlayer.name}`);
                skipPlayerTurn(currentPlayer, effect.turns || 1);
            } else {
                console.warn(`Unknown effect type: ${effect.type}`, effect);
            }
        });
        return;
    }
    
    // Handle role-based effects
    if (typeof card.effects === 'object') {
        const playerRole = currentPlayer.role;
        if (!playerRole) {
            console.error('Player has no role assigned');
            processEndPlayerTurn(card);
            return;
        }
        
        // Try different case variants of the role name
        const roleVariants = [
            playerRole,
            playerRole.toUpperCase(),
            playerRole.toLowerCase(),
            playerRole.charAt(0).toUpperCase() + playerRole.slice(1).toLowerCase()
        ];
        
        let roleEffect = null;
        let matchedRole = null;
        
        for (const roleVariant of roleVariants) {
            if (card.effects[roleVariant]) {
                roleEffect = card.effects[roleVariant];
                matchedRole = roleVariant;
                break;
            }
        }
        
        if (roleEffect) {
            //console.log(`Found effects for role variant: ${matchedRole}`);
            if (Array.isArray(roleEffect)) {
                roleEffect.forEach(effect => handleEffect(effect, currentPlayer, card));
            } else {
                handleEffect(roleEffect, currentPlayer, card);
            }
        } else {
            //console.log(`No effects found for role: ${playerRole} (tried variants: ${roleVariants.join(', ')})`);
            //console.log('Available roles in card effects:', Object.keys(card.effects));
            processEndPlayerTurn(card);
        }
    }
    
    //console.log(`Found effects for role variant: ${matchedRole}`);
    //console.log(`Processing effect: ${roleEffect.type}`);
    
    if (roleEffect.explanation) {
        //console.log(`Effect explanation: ${roleEffect.explanation}`);
    }
    
    // Verify this is a resource change effect
    if (roleEffect.type !== 'RESOURCE_CHANGE' || !roleEffect.changes) {
        console.warn(`Effect for ${matchedRole} is not a resource change or has no changes`);
        //console.log('Available effect:', roleEffect);
        console.log('------------processCardEffects END------------')
        console.log('*****************call updateResourceDisplays*****************');
        updateResourceDisplays();
        processEndPlayerTurn(card);
        return;
    }
    
    // Apply the resource changes using your existing applyResourceChange function
    const changes = roleEffect.changes;
    
    //console.log(`Applying resource changes:`, changes);
    
    // Apply each resource change individually using your existing function
    if (changes.money !== undefined) {
        //console.log(`Applying money change: ${changes.money}`);
        await applyResourceChange('money', changes.money, 'cardEffect', currentPlayer.id);
    }
    
    if (changes.knowledge !== undefined) {
        //console.log(`Applying knowledge change: ${changes.knowledge}`);
        await applyResourceChange('knowledge', changes.knowledge, 'cardEffect', currentPlayer.id);
    }
    
    if (changes.influence !== undefined) {
        //console.log(`Applying influence change: ${changes.influence}`);
        await applyResourceChange('influence', changes.influence, 'cardEffect', currentPlayer.id);
    }
    
    // Log the changes for debugging/feedback
    //console.log(`Applied effects for ${matchedRole}:`);
    //console.log(`- Money: ${changes.money || 0}`);
    //console.log(`- Knowledge: ${changes.knowledge || 0}`);
    //console.log(`- influence: ${changes.influence || 0}`);
    //console.log(`- Explanation: ${roleEffect.explanation}`);
    
    console.log('---------processCardEffects END---------');
    // Call processEndPlayerTurn when complete, passing the card
    updatePlayerInfo(currentPlayer);
    processEndPlayerTurn(card);
}
  
  /*
   * Validates and finalizes all age card effects, then calls handleEndTurn
   * This is the guard function that ensures all effects were properly applied
   * @param {Object} card - The original card object
   * @param {Array} effects - Array of effects that were processed
   */
  /*
  export async function processAgeCardEffects(card, effects) {
    console.log('================processAgeCardEffects================');
    //console.log('Validating effects for card:', card.name);
      
      // Validate that all effects were processed
      let allEffectsApplied = true;
      const validationErrors = [];
      
      if (effects.length === 0) {
        console.warn('No effects were found on this card');
        validationErrors.push('No effects found');
        allEffectsApplied = false;
      }
      
      // Check each effect type was handled appropriately
      effects.forEach((effect, index) => {
        if (!effect || !effect.type) {
          validationErrors.push(`Effect ${index + 1}: Missing or invalid effect type`);
          allEffectsApplied = false;
        }
      });
      
      // Log validation results
      if (!allEffectsApplied) {
        console.warn('Some age card effects may not have been properly applied:', validationErrors);
      } else {
        //console.log('All age card effects have been successfully processed');
      }
      
      // Update player resources and UI (this ensures all changes are reflected)
      const currentPlayer = getCurrentPlayer();
      if (currentPlayer) {
        // Force update of resource panel
        const resourceEvent = new CustomEvent('resourcesUpdated', {
          detail: { playerId: currentPlayer.id }
        });
        document.dispatchEvent(resourceEvent);
      }
      
      // Reset game state flags
      state.preventCardDraw = false;
      
      //console.log('processAgeCardEffects validation complete - calling handleEndTurn');
      
      // Always call handleEndTurn regardless of validation results
      updatePlayerInfo(currentPlayer);
      // This ensures the game doesn't get stuck
      console.log('---------processAgeCardEffects END---------');
      handleEndTurn();
}
*/
/**
 * 
 * Updates the player information panel with the current player's stats.
 * @param {string|Object} playerId - The ID of the player to display, or a player object.
 */
/*
export function updatePlayerInfo(currentPlayer = getCurrentPlayer(), newValues = {}) {
    console.log('==============updatePlayerInfo (state sync helper)=============')
    try {
        // Normalize to player object
        if (!currentPlayer) currentPlayer = getCurrentPlayer();
        if (typeof currentPlayer === 'string') currentPlayer = getPlayerById(currentPlayer);
        if (!currentPlayer) {
            console.warn('updatePlayerInfo: No current player found');
            return;
        }

        // Ensure mirrors exist
        state.playerResources = state.playerResources || {};

        // Compute canonical resources from player.resources merged with newValues
        const base = currentPlayer.resources || { knowledge: 0, money: 0, influence: 0 };
        const merged = { ...base, ...newValues };

        // Mirror to state.playerResources
        state.playerResources[currentPlayer.id] = { ...merged };

        // Optionally mirror to legacy _state if present (uses state.game.resources)
        if (typeof _state !== 'undefined' && _state?.game) {
            _state.game.resources = _state.game.resources || {};
            _state.game.resources[currentPlayer.id] = JSON.parse(JSON.stringify(merged));
        }

        // Optionally mirror a flat state.game.resources if your app uses one
        if (state.game) {
            state.game.resources = state.game.resources || {};
            state.game.resources[currentPlayer.id] = { ...merged };
        }

        console.log('[StateSync] Mirrors updated for', currentPlayer.name, merged);
    } catch (error) {
        console.error('Error in updatePlayerInfo (state sync):', error);
    }
}; 
*/
// Legacy updatePlayerResources(playerId, resources) removed.
// Use the unified updatePlayerResources(currentPlayer, changes) below.

/**
 * Updates the resource displays based on the current game state
 * @param {Object} gameState - The current game state (optional, will use global state if not provided)
 */
/*
export function updateResourceDisplays(gameState = state) {
  console.log('=============updateResourceDisplays=============');
    
    const players = gameState.players || [];
    const currentPlayerIndex = gameState.currentPlayerIndex || 0;
    
    if (!players.length) {
      console.warn('No players found in game state');
      return;
    }
  
    // Get the display containers from the HTML
    const resourceDisplayContainer = document.getElementById('resource-Display-Container');
    const playerScoreDisplay = document.querySelector('.player-Score-Display');
  
    // Safety check to ensure the containers exist in your HTML
    if (!resourceDisplayContainer || !playerScoreDisplay) {
      console.warn("Resource display containers not found. Please check the IDs in your index.html.");
      return;
    }
  
    // No need to clear anything - just update existing elements
    // Get existing player score elements
    const playerScoreElements = playerScoreDisplay.querySelectorAll('h5');
  
    const currentPlayer = players[currentPlayerIndex];
    const humanPlayers = players.filter(p => p.isHuman);
    const aiPlayers = players.filter(p => !p.isHuman);
  
    let playerForBottomDisplay = null;
  
    // --- Logic for the Bottom Display Container ---
    // If there's only one human player, always show them.
    if (humanPlayers.length === 1) {
      playerForBottomDisplay = humanPlayers[0];
    } 
    // If there are multiple human players, show the one whose turn it is.
    else if (humanPlayers.length > 1) {
      if (currentPlayer?.isHuman) {
        playerForBottomDisplay = currentPlayer;
      }
    }
  
    // Populate the bottom display if a player has been selected
    if (playerForBottomDisplay) {
      // Update existing DOM elements directly
      const currentPlayerSpan = document.getElementById('currentPlayer');
      const knowledgeCount = document.getElementById('KNOWLEDGE_COUNT');
      const moneyCount = document.getElementById('MONEY_COUNT');
      const influenceCount = document.getElementById('INFLUENCE_COUNT');
        
      if (currentPlayerSpan) {
        currentPlayerSpan.textContent = playerForBottomDisplay.role || 'Player';
      }
      if (knowledgeCount) {
        knowledgeCount.textContent = playerForBottomDisplay.resources?.knowledge || 0;
      }
      if (moneyCount) {
        moneyCount.textContent = playerForBottomDisplay.resources?.money || 0;
      }
      if (influenceCount) {
        influenceCount.textContent = playerForBottomDisplay.resources?.influence || 0;
      }
    }
  
    // --- Logic for the Top Score Display ---
    const playersForTopDisplay = [];
    
    // Add all AI players who are active in the game
    aiPlayers.forEach(player => {
      if (players.includes(player)) {
        playersForTopDisplay.push(player);
      }
    });
    
    // Add any human players who are NOT being shown in the bottom display
    humanPlayers.forEach(player => {
      if (player !== playerForBottomDisplay && players.includes(player)) {
        playersForTopDisplay.push(player);
      }
    });
  
    // Update existing player score elements
    playerScoreElements.forEach((element, index) => {
      const roleNameSpan = element.querySelector('.role-Name');
      const resourceParagraph = element.querySelector('p');
        
      if (index < playersForTopDisplay.length) {
        const player = playersForTopDisplay[index];
        const roleName = player.role || `Player ${player.id?.slice(0, 4) || '?'}`;
        const resources = player.resources || {};
            
        if (roleNameSpan) {
          roleNameSpan.textContent = roleName;
        }
        if (resourceParagraph) {
          resourceParagraph.textContent = `${resources.money || 0} 💰, ${resources.knowledge || 0} 🧠, ${resources.influence || 0} ⚡`;
        }
            
        // Make sure the element is visible
        element.style.display = '';
      } else {
        // Hide unused elements
        element.style.display = 'none';
      }
    });
    
    console.log('=============updateResourceDisplays END=============');
}
*/

/**
   * Update a player's resources in global state
   * @param {string} playerId - The ID of the player
   * @param {Object} resources - The new resource values
   */
/*
export function updatePlayerResources(currentPlayer, changes) {
  console.log('=============updatePlayerResources=============');
    
    // Handle single parameter call (just changes object)
    if (arguments.length === 1 && currentPlayer && typeof currentPlayer === 'object' && !Array.isArray(currentPlayer)) {
      changes = currentPlayer;
      currentPlayer = getCurrentPlayer();
    } else if (!changes) {
      // If changes is not provided, treat the first param as changes
      changes = currentPlayer;
      currentPlayer = getCurrentPlayer();
    }
    
    // If currentPlayer is a string, treat it as playerId
    if (typeof currentPlayer === 'string') {
      currentPlayer = getPlayerById(currentPlayer);
    } else if (!currentPlayer) {
      // Fallback to current player if not provided
      currentPlayer = getCurrentPlayer();
    }
    
    // Find the player in the global state
    const players = getPlayers ? getPlayers() : []; // Safety check
    
    if (!currentPlayer || !changes) {
      console.error('Invalid parameters for updatePlayerResources:', { 
        currentPlayer: currentPlayer?.id || 'undefined', 
        changes 
      });
      return false;
    }
  
    // Validate player has resources object
    if (!currentPlayer.resources) {
        console.error('Player missing resources object:', currentPlayer);
        return false;
    }
  
    // Define valid resources
    const RESOURCES = ['knowledge', 'money', 'influence'];
  
    // Validate and normalize changes
    const normalizedChanges = {};
    let isValid = true;
    for (const resource in changes) {
        if (!RESOURCES.includes(resource)) {
            console.warn(`Invalid resource type '${resource}' ignored`);
            continue;
        }
  
        const change = Number(changes[resource]);
        if (isNaN(change)) {
            console.error(`Invalid change value for ${resource}:`, changes[resource]);
            isValid = false;
            break;
        }
  
        normalizedChanges[resource] = change;
    }
  
    if (!isValid) return false;
  
    // Calculate new values first to ensure all changes are valid
    const newValues = { ...currentPlayer.resources };
    for (const [resource, change] of Object.entries(normalizedChanges)) {
        const currentValue = newValues[resource] || 0;
        const newValue = currentValue + change;
  
        // Prevent negative resources
        if (newValue < 0) {
            console.error(`Cannot update ${resource}: would result in negative value (${newValue})`);
            return false;
        }
  
        newValues[resource] = newValue;
    }
  
    // Apply validated changes to the player object (single source of truth)
  currentPlayer.resources = { ...newValues };

  // Update the global state with the modified player
  const updatedPlayers = players.map(p =>
    p.id === currentPlayer.id ? { ...p, resources: { ...newValues } } : p
  );

  // Sync other state mirrors via helper (no DOM here)
  if (typeof updatePlayerInfo === 'function') {
    updatePlayerInfo(currentPlayer, newValues);
  }

  // Push updated players to state
  if (typeof updateGameState === 'function') {
    updateGameState({ players: updatedPlayers });
  }

  // Notify subscribers to trigger UI updates
  if (typeof notifySubscribers === 'function') {
    notifySubscribers();
  }
    
    console.log(`[Resources] Updated resources for ${currentPlayer.name}:`, newValues);
    
    return true;
}
*/


/* ========================= */
/*        JAVASCRIPT         */
/* ========================= */

document.addEventListener("DOMContentLoaded", () => {

  // Get references to start screen and player count screen (YOUR ORIGINAL CODE)
  const startScreen = document.getElementById("start-Screen");
  const startButton = document.getElementById("start-Button");
  const playerCountScreen = document.getElementById("player-Count-Screen");
          
  // Hide the player count screen initially (YOUR ORIGINAL CODE)
  playerCountScreen.classList.add("hidden");
      
  // YOUR ORIGINAL START BUTTON FUNCTIONALITY
  startButton.addEventListener("click", () => {
      startScreen.classList.add("hidden");
      playerCountScreen.classList.remove("hidden");
  });
  
  // Get references to start screen and player count screen (YOUR ORIGINAL CODE)
  const rulesButton = document.getElementById("rules-Button");
  
  // YOUR ORIGINAL START BUTTON FUNCTIONALITY
  rulesButton.addEventListener("click", () => {
      rulesModal.classList.remove("hidden");
  });

  // ========== ADDED RULES FUNCTIONALITY BELOW ==========
  
  // Rules modal elements
  const rulesModal = document.getElementById("rules-Modal");
  const closeRulesButton = document.getElementById("close-Rules-Button");
  const prevCardButton = document.getElementById("previous-Card-Button");
  const nextCardButton = document.getElementById("next-Card-Button");
  const rulesCardContent = document.getElementById("rules-Card-Content");
  const cardIndicator = document.getElementById("card-Indicator");
  const rulesCards = document.querySelectorAll(".rules-card-item");
  
  // Rules data for dynamic cards (first card is in HTML)
  const additionalRulesCards = [
      {
          title: "Setup & Components",
          content: `
              <h3>Game Setup</h3>
              <p><strong>What's Included:</strong></p>
              <ul>
                  <li>Main deck of cards</li>
                  <li>Player boards</li>
                  <li>Scoring tokens</li>
                  <li>Reference cards</li>
              </ul>
              <p><strong>Setup Steps:</strong></p>
              <ol>
                  <li>Each player receives a starting hand</li>
                  <li>Place the main deck in the center</li>
                  <li>Distribute player boards and tokens</li>
                  <li>Randomly determine the first player</li>
              </ol>
          `
      },
      {
          title: "Turn Structure",
          content: `
              <h3>How to Play</h3>
              <p><strong>Each turn consists of:</strong></p>
              <ol>
                  <li><strong>Draw Phase:</strong> Draw cards from the deck</li>
                  <li><strong>Action Phase:</strong> Play cards and take actions</li>
                  <li><strong>Resolve Phase:</strong> Apply card effects</li>
                  <li><strong>End Phase:</strong> Discard excess cards</li>
              </ol>
              <p><strong>Turn Order:</strong> Play proceeds clockwise around the table.</p>
          `
      },
      {
          title: "Card Types & Actions",
          content: `
              <h3>Understanding Cards</h3>
              <p><strong>Action Cards:</strong> Immediate effects when played</p>
              <p><strong>Resource Cards:</strong> Provide ongoing benefits</p>
              <p><strong>Attack Cards:</strong> Target other players</p>
              <p><strong>Defense Cards:</strong> Protect against attacks</p>
              <p><strong>Special Cards:</strong> Unique effects that can change the game</p>
              <br>
              <p><strong>Playing Cards:</strong> Most cards have a cost and must be paid to play them.</p>
          `
      },
      {
          title: "Winning Conditions",
          content: `
              <h3>How to Win</h3>
              <p>Victory can be achieved through multiple paths:</p>
              <ul>
                  <li><strong>Point Victory:</strong> First to reach the target score</li>
                  <li><strong>Elimination Victory:</strong> Last player remaining</li>
                  <li><strong>Special Victory:</strong> Complete unique win conditions</li>
              </ul>
              <p><strong>End Game:</strong> The game ends immediately when any player achieves a victory condition.</p>
              <p><strong>Tie Breaking:</strong> In case of ties, the player with the most cards in hand wins.</p>
          `
      }
  ];
  
  let currentCardIndex = 0;
  let totalCards = 5; // 1 in HTML + 4 dynamic cards
  let dynamicCardsCreated = false;
  
  // Hide rules modal initially
  if (rulesModal) rulesModal.classList.add("hidden");
  
  // Rules button functionality
  if (rulesButton) {
      rulesButton.addEventListener("click", () => {
          showRulesModal();
      });
  }
  
  // Close rules modal
  if (closeRulesButton) {
      closeRulesButton.addEventListener("click", () => {
          hideRulesModal();
      });
  }
  
  // Navigation buttons
  if (prevCardButton) {
      prevCardButton.addEventListener("click", () => {
          if (currentCardIndex > 0) {
              currentCardIndex--;
              updateRulesCard();
          }
      });
  }
  
  if (nextCardButton) {
      nextCardButton.addEventListener("click", () => {
          if (currentCardIndex < totalCards - 1) {
              currentCardIndex++;
              updateRulesCard();
          }
      });
  }
  
  // Close modal when clicking outside of it
  if (rulesModal) {
      rulesModal.addEventListener("click", (e) => {
          if (e.target === rulesModal) {
              hideRulesModal();
          }
      });
  }
  
  // Keyboard navigation
  document.addEventListener("keydown", (e) => {
      if (rulesModal && !rulesModal.classList.contains("hidden")) {
          if (e.key === "Escape") {
              hideRulesModal();
          } else if (e.key === "ArrowLeft" && currentCardIndex > 0) {
              currentCardIndex--;
              updateRulesCard();
          } else if (e.key === "ArrowRight" && currentCardIndex < totalCards - 1) {
              currentCardIndex++;
              updateRulesCard();
          }
      }
  });
  
  // Rules Functions
  function showRulesModal() {
      currentCardIndex = 0; // Reset to first card
      
      // Create dynamic cards if not already created
      if (!dynamicCardsCreated) {
          createDynamicCards();
          dynamicCardsCreated = true;
      }
      
      updateRulesCard();
      if (rulesModal) {
          rulesModal.classList.remove("hidden");
          document.body.classList.add("no-scroll");
      }
  }
  
  function hideRulesModal() {
      if (rulesModal) {
          rulesModal.classList.add("hidden");
          document.body.classList.remove("no-scroll");
      }
  }
  
  function createDynamicCards() {
      if (!rulesCardContent) return;
      
      // Create additional cards dynamically
      additionalRulesCards.forEach((cardData, index) => {
          const cardElement = document.createElement('div');
          cardElement.className = 'rules-card-item';
          cardElement.setAttribute('data-card', (index + 1).toString());
          cardElement.innerHTML = `
              <h2>${cardData.title}</h2>
              ${cardData.content}
          `;
          rulesCardContent.appendChild(cardElement);
      });
  }
  
  function updateRulesCard() {
      // Get all cards (including dynamically created ones)
      const allCards = document.querySelectorAll(".rules-card-item");
      
      // Hide all cards
      allCards.forEach(card => {
          card.classList.remove("active");
      });
      
      // Show current card
      if (allCards[currentCardIndex]) {
          allCards[currentCardIndex].classList.add("active");
      }
      
      // Update indicator
      if (cardIndicator) {
          cardIndicator.textContent = `${currentCardIndex + 1} of ${totalCards}`;
      }
      
      // Update navigation buttons
      if (prevCardButton) {
          if (currentCardIndex === 0) {
              prevCardButton.classList.add("disabled");
              prevCardButton.disabled = true;
          } else {
              prevCardButton.classList.remove("disabled");
              prevCardButton.disabled = false;
          }
      }
      
      if (nextCardButton) {
          if (currentCardIndex === totalCards - 1) {
              nextCardButton.classList.add("disabled");
              nextCardButton.disabled = true;
          } else {
              nextCardButton.classList.remove("disabled");
              nextCardButton.disabled = false;
          }
      }
  }
      // Show current card
      if (rulesCards[currentCardIndex]) {
          rulesCards[currentCardIndex].classList.add("active");
      }
      
      // Update indicator
      if (cardIndicator) {
          cardIndicator.textContent = `${currentCardIndex + 1} of ${totalCards}`;
      }
      
      // Update navigation buttons
      if (prevCardButton) {
          if (currentCardIndex === 0) {
              prevCardButton.classList.add("disabled");
              prevCardButton.disabled = true;
          } else {
              prevCardButton.classList.remove("disabled");
              prevCardButton.disabled = false;
          }
      }
      
      if (nextCardButton) {
          if (currentCardIndex === totalCards - 1) {
              nextCardButton.classList.add("disabled");
              nextCardButton.disabled = true;
          } else {
              nextCardButton.classList.remove("disabled");
              nextCardButton.disabled = false;
          }
      }
  }
);
